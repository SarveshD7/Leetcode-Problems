Problem Statement - 
Given a reference of a node in a connected undirected graph.
Return a deep copy (clone) of the graph.
Each node in the graph contains a value (int) and a list (List[Node]) of its neighbors.
class Node {
    public int val;
    public List<Node> neighbors;
}
 
Example - 
Input: adjList = [[2,4],[1,3],[2,4],[1,3]]
Output: [[2,4],[1,3],[2,4],[1,3]]
Explanation: There are 4 nodes in the graph.
1st node (val = 1)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
2nd node (val = 2)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).
3rd node (val = 3)'s neighbors are 2nd node (val = 2) and 4th node (val = 4).
4th node (val = 4)'s neighbors are 1st node (val = 1) and 3rd node (val = 3).

-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

Solution - 
class Solution {
public:
    unordered_map<Node*, Node*>m;
    Node* ans=NULL;
    void solve(Node* node){
        if(!node || m.find(node)!=m.end()) return ;
        Node* nr = m[node];
        if(!nr){
            nr = new Node(node->val), m[node]=nr;
            if(!ans) ans=nr;
        }
        for(auto i:node->neighbors){
            solve(i);
            if(m.find(i)==m.end()){
                Node* n = new Node(i->val);
                m[i]=n;
                nr->neighbors.push_back(n);
            }else nr->neighbors.push_back(m[i]);
        }
        
        return ;
    }
    Node* cloneGraph(Node* node) {
        if(!node) return ans;
        ans=NULL;
        m.erase(m.begin(), m.end());
        Node* t=NULL;
        solve(node);
        return ans;
        
    }
};
