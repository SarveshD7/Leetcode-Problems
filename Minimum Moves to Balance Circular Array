Problem Statement - 
You are given a circular array balance of length n, where balance[i] is the net balance of person i.
In one move, a person can transfer exactly 1 unit of balance to either their left or right neighbor.
Return the minimum number of moves required so that every person has a non-negative balance. If it is impossible, return -1.
Note: You are guaranteed that at most 1 index has a negative balance initially.

Example - 
Input: balance = [5,1,-4]
Output: 4
Explanation:
One optimal sequence of moves is:
Move 1 unit from i = 1 to i = 2, resulting in balance = [5, 0, -3]
Move 1 unit from i = 0 to i = 2, resulting in balance = [4, 0, -2]
Move 1 unit from i = 0 to i = 2, resulting in balance = [3, 0, -1]
Move 1 unit from i = 0 to i = 2, resulting in balance = [2, 0, 0]
Thus, the minimum number of moves required is 4.

----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------


Solution - 
class Solution {
public:
    long long  solve(long long& i, vector<int>& b){
        int j=i-1, k=i+1,  v1, v2, d=1;
        long long v=abs(b[i]),ans=0;
        while(d<b.size() && v>0){
            v1=(i-d>=0)?(i-d):(b.size()-(d-i)), v2=(i+d<b.size())?(i+d):((d+i)-b.size());
            ans+=min(v, (long long) b[v1])*d, v-=min(v, (long long) b[v1]),b[v1]=0;
            ans+=min(v, (long long) b[v2])*d, v-=min(v, (long long)b[v2]),b[v2]=0;
            d++;
        }
        return ans;
    }
    long long minMoves(vector<int>& balance) {
        long long s = 0, pos=-1;
        for(int i=0;i<balance.size();i++){
            s+=balance[i];
            if(balance[i]<0) pos = i;
        }
        if(s<0) return -1;
        if(pos==-1) return 0;
        return solve(pos, balance);
    }
};
